/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import { BaseResource } from 'ms-rest-azure';
import { CloudError } from 'ms-rest-azure';
import * as moment from 'moment';

export { BaseResource } from 'ms-rest-azure';
export { CloudError } from 'ms-rest-azure';


/**
 * @class
 * Initializes a new instance of the ServiceTypeDeltaHealthPolicy class.
 * @constructor
 * Represents the delta health policy used to evaluate the health of services
 * belonging to a service type when upgrading the cluster.
 *
 *
 * @member {number} [maxPercentDeltaUnhealthyServices] The maximum allowed
 * percentage of services health degradation allowed during cluster upgrades.
 * The delta is measured between the state of the services at the beginning of
 * upgrade and the state of the services at the time of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits.
 * . Default value: 0 .
 */
export interface ServiceTypeDeltaHealthPolicy {
  maxPercentDeltaUnhealthyServices?: number;
}

/**
 * @class
 * Initializes a new instance of the ServiceTypeDeltaHealthPolicyMapItem class.
 * @constructor
 * Defines an item in ServiceTypeDeltaHealthPolicyMap.
 *
 *
 * @member {string} key The key of the service type delta health policy map
 * item. This is the name of the service type.
 * @member {object} value The value of the service type delta health policy map
 * item. This is the ServiceTypeDeltaHealthPolicy for this service type.
 * @member {number} [value.maxPercentDeltaUnhealthyServices] The maximum
 * allowed percentage of services health degradation allowed during cluster
 * upgrades.
 * The delta is measured between the state of the services at the beginning of
 * upgrade and the state of the services at the time of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits.
 */
export interface ServiceTypeDeltaHealthPolicyMapItem {
  key: string;
  value: ServiceTypeDeltaHealthPolicy;
}

/**
 * @class
 * Initializes a new instance of the ApplicationDeltaHealthPolicy class.
 * @constructor
 * Defines a delta health policy used to evaluate the health of an application
 * or one of its child entities when upgrading the cluster.
 *
 *
 * @member {object} [defaultServiceTypeDeltaHealthPolicy] The delta health
 * policy used by default to evaluate the health of a service type when
 * upgrading the cluster.
 * @member {number}
 * [defaultServiceTypeDeltaHealthPolicy.maxPercentDeltaUnhealthyServices] The
 * maximum allowed percentage of services health degradation allowed during
 * cluster upgrades.
 * The delta is measured between the state of the services at the beginning of
 * upgrade and the state of the services at the time of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits.
 * @member {array} [serviceTypeDeltaHealthPolicies] The map with service type
 * delta health policy per service type name. The map is empty by default.
 */
export interface ApplicationDeltaHealthPolicy {
  defaultServiceTypeDeltaHealthPolicy?: ServiceTypeDeltaHealthPolicy;
  serviceTypeDeltaHealthPolicies?: ServiceTypeDeltaHealthPolicyMapItem[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationDeltaHealthPolicyMapItem class.
 * @constructor
 * Defines an item in ApplicationDeltaHealthPolicyMap.
 *
 *
 * @member {string} key The key of the application delta health policy map
 * item. This is the name of the application.
 * @member {object} value The value of the application delta health policy map
 * item. This is the ApplicationDeltaHealthPolicy for this application.
 * @member {object} [value.defaultServiceTypeDeltaHealthPolicy] The delta
 * health policy used by default to evaluate the health of a service type when
 * upgrading the cluster.
 * @member {number}
 * [value.defaultServiceTypeDeltaHealthPolicy.maxPercentDeltaUnhealthyServices]
 * The maximum allowed percentage of services health degradation allowed during
 * cluster upgrades.
 * The delta is measured between the state of the services at the beginning of
 * upgrade and the state of the services at the time of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits.
 * @member {array} [value.serviceTypeDeltaHealthPolicies] The map with service
 * type delta health policy per service type name. The map is empty by default.
 */
export interface ApplicationDeltaHealthPolicyMapItem {
  key: string;
  value: ApplicationDeltaHealthPolicy;
}

/**
 * @class
 * Initializes a new instance of the ServiceTypeHealthPolicy class.
 * @constructor
 * Represents the health policy used to evaluate the health of services
 * belonging to a service type.
 *
 *
 * @member {number} [maxPercentUnhealthyServices] The maximum percentage of
 * services allowed to be unhealthy before your application is considered in
 * error.
 * . Default value: 0 .
 */
export interface ServiceTypeHealthPolicy {
  maxPercentUnhealthyServices?: number;
}

/**
 * @class
 * Initializes a new instance of the ServiceTypeHealthPolicyMapItem class.
 * @constructor
 * Defines an item in ServiceTypeHealthPolicyMap.
 *
 *
 * @member {string} key The key of the service type health policy map item.
 * This is the name of the service type.
 * @member {object} value The value of the service type health policy map item.
 * This is the ServiceTypeHealthPolicy for this service type.
 * @member {number} [value.maxPercentUnhealthyServices] The maximum percentage
 * of services allowed to be unhealthy before your application is considered in
 * error.
 */
export interface ServiceTypeHealthPolicyMapItem {
  key: string;
  value: ServiceTypeHealthPolicy;
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthPolicy class.
 * @constructor
 * Defines a health policy used to evaluate the health of an application or one
 * of its children entities.
 *
 *
 * @member {object} [defaultServiceTypeHealthPolicy] The health policy used by
 * default to evaluate the health of a service type.
 * @member {number}
 * [defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices] The maximum
 * percentage of services allowed to be unhealthy before your application is
 * considered in error.
 * @member {array} [serviceTypeHealthPolicies] The map with service type health
 * policy per service type name. The map is empty by default.
 * @member {boolean} [considerWarningAsError] Indicates whether warnings are
 * treated with the same severity as errors. Default value: false .
 * @member {number} [maxPercentUnhealthyDeployedApplications] The maximum
 * allowed percentage of unhealthy deployed applications. Allowed values are
 * Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 * . Default value: 0 .
 * @member {object} [defaultServiceTypeHealthPolicy1] The health policy used by
 * default to evaluate the health of a service type.
 * @member {number}
 * [defaultServiceTypeHealthPolicy1.maxPercentUnhealthyServices] The maximum
 * percentage of services allowed to be unhealthy before your application is
 * considered in error.
 * @member {array} [serviceTypeHealthPolicyMap] The map with service type
 * health policy per service type name. The map is empty by default.
 */
export interface ApplicationHealthPolicy {
  defaultServiceTypeHealthPolicy?: ServiceTypeHealthPolicy;
  serviceTypeHealthPolicies?: ServiceTypeHealthPolicyMapItem[];
  considerWarningAsError?: boolean;
  maxPercentUnhealthyDeployedApplications?: number;
  defaultServiceTypeHealthPolicy1?: ServiceTypeHealthPolicy;
  serviceTypeHealthPolicyMap?: ServiceTypeHealthPolicyMapItem[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationHealthPolicyMapItem class.
 * @constructor
 * Defines an item in ApplicationHealthPolicyMap.
 *
 *
 * @member {string} key The key of the application health policy map item. This
 * is the name of the application.
 * @member {object} value The value of the application health policy map item.
 * This is the ApplicationHealthPolicy for this application.
 * @member {object} [value.defaultServiceTypeHealthPolicy] The health policy
 * used by default to evaluate the health of a service type.
 * @member {number}
 * [value.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices] The
 * maximum percentage of services allowed to be unhealthy before your
 * application is considered in error.
 * @member {array} [value.serviceTypeHealthPolicies] The map with service type
 * health policy per service type name. The map is empty by default.
 * @member {boolean} [value.considerWarningAsError] Indicates whether warnings
 * are treated with the same severity as errors.
 * @member {number} [value.maxPercentUnhealthyDeployedApplications] The maximum
 * allowed percentage of unhealthy deployed applications. Allowed values are
 * Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 * @member {object} [value.defaultServiceTypeHealthPolicy1] The health policy
 * used by default to evaluate the health of a service type.
 * @member {number}
 * [value.defaultServiceTypeHealthPolicy1.maxPercentUnhealthyServices] The
 * maximum percentage of services allowed to be unhealthy before your
 * application is considered in error.
 * @member {array} [value.serviceTypeHealthPolicyMap] The map with service type
 * health policy per service type name. The map is empty by default.
 */
export interface ApplicationHealthPolicyMapItem {
  key: string;
  value: ApplicationHealthPolicy;
}

/**
 * @class
 * Initializes a new instance of the AvailableOperationDisplay class.
 * @constructor
 * Operation supported by Service Fabric resource provider
 *
 * @member {string} [provider] The name of the provider.
 * @member {string} [resource] The resource on which the operation is performed
 * @member {string} [operation] The operation that can be performed.
 * @member {string} [description] Operation description
 */
export interface AvailableOperationDisplay {
  provider?: string;
  resource?: string;
  operation?: string;
  description?: string;
}

/**
 * @class
 * Initializes a new instance of the AzureActiveDirectory class.
 * @constructor
 * The settings to enable AAD authentication on the cluster.
 *
 * @member {string} [tenantId] Azure active directory tenant id.
 * @member {string} [clusterApplication] Azure active directory cluster
 * application id.
 * @member {string} [clientApplication] Azure active directory client
 * application id.
 */
export interface AzureActiveDirectory {
  tenantId?: string;
  clusterApplication?: string;
  clientApplication?: string;
}

/**
 * @class
 * Initializes a new instance of the CertificateDescription class.
 * @constructor
 * Describes the certificate details.
 *
 * @member {string} thumbprint Thumbprint of the primary certificate.
 * @member {string} [thumbprintSecondary] Thumbprint of the secondary
 * certificate.
 * @member {string} [x509StoreName] The local certificate store location.
 * Possible values include: 'AddressBook', 'AuthRoot', 'CertificateAuthority',
 * 'Disallowed', 'My', 'Root', 'TrustedPeople', 'TrustedPublisher'
 */
export interface CertificateDescription {
  thumbprint: string;
  thumbprintSecondary?: string;
  x509StoreName?: string;
}

/**
 * @class
 * Initializes a new instance of the ClientCertificateCommonName class.
 * @constructor
 * Describes the client certificate details using common name.
 *
 * @member {boolean} isAdmin Indicates if the client certificate has admin
 * access to the cluster. Non admin clients can perform only read only
 * operations on the cluster.
 * @member {string} certificateCommonName The common name of the client
 * certificate.
 * @member {string} certificateIssuerThumbprint The issuer thumbprint of the
 * client certificate.
 */
export interface ClientCertificateCommonName {
  isAdmin: boolean;
  certificateCommonName: string;
  certificateIssuerThumbprint: string;
}

/**
 * @class
 * Initializes a new instance of the ClientCertificateThumbprint class.
 * @constructor
 * Describes the client certificate details using thumbprint.
 *
 * @member {boolean} isAdmin Indicates if the client certificate has admin
 * access to the cluster. Non admin clients can perform only read only
 * operations on the cluster.
 * @member {string} certificateThumbprint The thumbprint of the client
 * certificate.
 */
export interface ClientCertificateThumbprint {
  isAdmin: boolean;
  certificateThumbprint: string;
}

/**
 * @class
 * Initializes a new instance of the ClusterVersionDetails class.
 * @constructor
 * The detail of the Service Fabric runtime version result
 *
 * @member {string} [codeVersion] The Service Fabric runtime version of the
 * cluster.
 * @member {string} [supportExpiryUtc] The date of expiry of support of the
 * version.
 * @member {string} [environment] Indicates if this version is for Windows or
 * Linux operating system. Possible values include: 'Windows', 'Linux'
 */
export interface ClusterVersionDetails {
  codeVersion?: string;
  supportExpiryUtc?: string;
  environment?: string;
}

/**
 * @class
 * Initializes a new instance of the ServerCertificateCommonName class.
 * @constructor
 * Describes the server certificate details using common name.
 *
 * @member {string} certificateCommonName The common name of the server
 * certificate.
 * @member {string} certificateIssuerThumbprint The issuer thumbprint of the
 * server certificate.
 */
export interface ServerCertificateCommonName {
  certificateCommonName: string;
  certificateIssuerThumbprint: string;
}

/**
 * @class
 * Initializes a new instance of the ServerCertificateCommonNames class.
 * @constructor
 * Describes a list of server certificates referenced by common name that are
 * used to secure the cluster.
 *
 * @member {array} [commonNames] The list of server certificates referenced by
 * common name that are used to secure the cluster.
 * @member {string} [x509StoreName] The local certificate store location.
 * Possible values include: 'AddressBook', 'AuthRoot', 'CertificateAuthority',
 * 'Disallowed', 'My', 'Root', 'TrustedPeople', 'TrustedPublisher'
 */
export interface ServerCertificateCommonNames {
  commonNames?: ServerCertificateCommonName[];
  x509StoreName?: string;
}

/**
 * @class
 * Initializes a new instance of the DiagnosticsStorageAccountConfig class.
 * @constructor
 * The storage account information for storing Service Fabric diagnostic logs.
 *
 * @member {string} storageAccountName The Azure storage account name.
 * @member {string} protectedAccountKeyName The protected diagnostics storage
 * key name.
 * @member {string} blobEndpoint The blob endpoint of the azure storage
 * account.
 * @member {string} queueEndpoint The queue endpoint of the azure storage
 * account.
 * @member {string} tableEndpoint The table endpoint of the azure storage
 * account.
 */
export interface DiagnosticsStorageAccountConfig {
  storageAccountName: string;
  protectedAccountKeyName: string;
  blobEndpoint: string;
  queueEndpoint: string;
  tableEndpoint: string;
}

/**
 * @class
 * Initializes a new instance of the SettingsParameterDescription class.
 * @constructor
 * Describes a parameter in fabric settings of the cluster.
 *
 * @member {string} name The parameter name of fabric setting.
 * @member {string} value The parameter value of fabric setting.
 */
export interface SettingsParameterDescription {
  name: string;
  value: string;
}

/**
 * @class
 * Initializes a new instance of the SettingsSectionDescription class.
 * @constructor
 * Describes a section in the fabric settings of the cluster.
 *
 * @member {string} name The section name of the fabric settings.
 * @member {array} parameters The collection of parameters in the section.
 */
export interface SettingsSectionDescription {
  name: string;
  parameters: SettingsParameterDescription[];
}

/**
 * @class
 * Initializes a new instance of the EndpointRangeDescription class.
 * @constructor
 * Port range details
 *
 * @member {number} startPort Starting port of a range of ports
 * @member {number} endPort End port of a range of ports
 */
export interface EndpointRangeDescription {
  startPort: number;
  endPort: number;
}

/**
 * @class
 * Initializes a new instance of the NodeTypeDescription class.
 * @constructor
 * Describes a node type in the cluster, each node type represents sub set of
 * nodes in the cluster.
 *
 * @member {string} name The name of the node type.
 * @member {object} [placementProperties] The placement tags applied to nodes
 * in the node type, which can be used to indicate where certain services
 * (workload) should run.
 * @member {object} [capacities] The capacity tags applied to the nodes in the
 * node type, the cluster resource manager uses these tags to understand how
 * much resource a node has.
 * @member {number} clientConnectionEndpointPort The TCP cluster management
 * endpoint port.
 * @member {number} httpGatewayEndpointPort The HTTP cluster management
 * endpoint port.
 * @member {string} [durabilityLevel] The durability level of the node type.
 * Learn about
 * [DurabilityLevel](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-capacity).
 *
 * - Bronze - No privileges. This is the default.
 * - Silver - The infrastructure jobs can be paused for a duration of 10
 * minutes per UD.
 * - Gold - The infrastructure jobs can be paused for a duration of 2 hours per
 * UD. Gold durability can be enabled only on full node VM skus like D15_V2, G5
 * etc.
 * . Possible values include: 'Bronze', 'Silver', 'Gold'
 * @member {object} [applicationPorts] The range of ports from which cluster
 * assigned port to Service Fabric applications.
 * @member {number} [applicationPorts.startPort] Starting port of a range of
 * ports
 * @member {number} [applicationPorts.endPort] End port of a range of ports
 * @member {object} [ephemeralPorts] The range of empheral ports that nodes in
 * this node type should be configured with.
 * @member {number} [ephemeralPorts.startPort] Starting port of a range of
 * ports
 * @member {number} [ephemeralPorts.endPort] End port of a range of ports
 * @member {boolean} isPrimary The node type on which system services will run.
 * Only one node type should be marked as primary. Primary node type cannot be
 * deleted or changed for existing clusters.
 * @member {number} vmInstanceCount The number of nodes in the node type. This
 * count should match the capacity property in the corresponding
 * VirtualMachineScaleSet resource.
 * @member {number} [reverseProxyEndpointPort] The endpoint used by reverse
 * proxy.
 */
export interface NodeTypeDescription {
  name: string;
  placementProperties?: { [propertyName: string]: string };
  capacities?: { [propertyName: string]: string };
  clientConnectionEndpointPort: number;
  httpGatewayEndpointPort: number;
  durabilityLevel?: string;
  applicationPorts?: EndpointRangeDescription;
  ephemeralPorts?: EndpointRangeDescription;
  isPrimary: boolean;
  vmInstanceCount: number;
  reverseProxyEndpointPort?: number;
}

/**
 * @class
 * Initializes a new instance of the ClusterHealthPolicy class.
 * @constructor
 * Defines a health policy used to evaluate the health of the cluster or of a
 * cluster node.
 *
 *
 * @member {number} [maxPercentUnhealthyNodes] The maximum allowed percentage
 * of unhealthy nodes before reporting an error. For example, to allow 10% of
 * nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * . Default value: 0 .
 * @member {number} [maxPercentUnhealthyApplications] The maximum allowed
 * percentage of unhealthy applications before reporting an error. For example,
 * to allow 10% of applications to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * . Default value: 0 .
 * @member {array} [applicationHealthPolicies] Defines the application health
 * policy map used to evaluate the health of an application or one of its
 * children entities.
 */
export interface ClusterHealthPolicy {
  maxPercentUnhealthyNodes?: number;
  maxPercentUnhealthyApplications?: number;
  applicationHealthPolicies?: ApplicationHealthPolicyMapItem[];
}

/**
 * @class
 * Initializes a new instance of the ClusterUpgradeDeltaHealthPolicy class.
 * @constructor
 * Describes the delta health policies for the cluster upgrade.
 *
 * @member {number} maxPercentDeltaUnhealthyNodes The maximum allowed
 * percentage of nodes health degradation allowed during cluster upgrades.
 * The delta is measured between the state of the nodes at the beginning of
 * upgrade and the state of the nodes at the time of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits.
 * @member {number} maxPercentUpgradeDomainDeltaUnhealthyNodes The maximum
 * allowed percentage of upgrade domain nodes health degradation allowed during
 * cluster upgrades.
 * The delta is measured between the state of the upgrade domain nodes at the
 * beginning of upgrade and the state of the upgrade domain nodes at the time
 * of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion for all
 * completed upgrade domains to make sure the state of the upgrade domains is
 * within tolerated limits.
 * @member {number} maxPercentDeltaUnhealthyApplications The maximum allowed
 * percentage of applications health degradation allowed during cluster
 * upgrades.
 * The delta is measured between the state of the applications at the beginning
 * of upgrade and the state of the applications at the time of the health
 * evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits. System
 * services are not included in this.
 * @member {array} [applicationDeltaHealthPolicies] Defines the application
 * delta health policy map used to evaluate the health of an application or one
 * of its child entities when upgrading the cluster.
 */
export interface ClusterUpgradeDeltaHealthPolicy {
  maxPercentDeltaUnhealthyNodes: number;
  maxPercentUpgradeDomainDeltaUnhealthyNodes: number;
  maxPercentDeltaUnhealthyApplications: number;
  applicationDeltaHealthPolicies?: ApplicationDeltaHealthPolicyMapItem[];
}

/**
 * @class
 * Initializes a new instance of the ClusterUpgradePolicy class.
 * @constructor
 * Describes the policy used when upgrading the cluster.
 *
 * @member {boolean} [forceRestart] If true, then processes are forcefully
 * restarted during upgrade even when the code version has not changed (the
 * upgrade only changes configuration or data).
 * @member {string} upgradeReplicaSetCheckTimeout The maximum amount of time to
 * block processing of an upgrade domain and revent loss of availability when
 * there are unexpected issues. When this timeout expires, processing of the
 * upgrade domain will proceed regardless of availability loss issues. The
 * timeout is reset at the start of each upgrade domain. The timeout can be in
 * either hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {string} healthCheckWaitDuration The length of time to wait after
 * completing an upgrade domain before performing health checks. The duration
 * can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {string} healthCheckStableDuration The amount of time that the
 * application or cluster must remain healthy before the upgrade proceeds to
 * the next upgrade domain. The duration can be in either hh:mm:ss or in
 * d.hh:mm:ss.ms format.
 * @member {string} healthCheckRetryTimeout The amount of time to retry health
 * evaluation when the application or cluster is unhealthy before the upgrade
 * rolls back. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms
 * format.
 * @member {string} upgradeTimeout The amount of time the overall upgrade has
 * to complete before the upgrade rolls back. The timeout can be in either
 * hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {string} upgradeDomainTimeout The amount of time each upgrade domain
 * has to complete before the upgrade rolls back. The timeout can be in either
 * hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {object} healthPolicy The cluster health policy used when upgrading
 * the cluster.
 * @member {number} [healthPolicy.maxPercentUnhealthyNodes] The maximum allowed
 * percentage of unhealthy nodes before reporting an error. For example, to
 * allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @member {number} [healthPolicy.maxPercentUnhealthyApplications] The maximum
 * allowed percentage of unhealthy applications before reporting an error. For
 * example, to allow 10% of applications to be unhealthy, this value would be
 * 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @member {array} [healthPolicy.applicationHealthPolicies] Defines the
 * application health policy map used to evaluate the health of an application
 * or one of its children entities.
 * @member {object} [deltaHealthPolicy] The cluster delta health policy used
 * when upgrading the cluster.
 * @member {number} [deltaHealthPolicy.maxPercentDeltaUnhealthyNodes] The
 * maximum allowed percentage of nodes health degradation allowed during
 * cluster upgrades.
 * The delta is measured between the state of the nodes at the beginning of
 * upgrade and the state of the nodes at the time of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits.
 * @member {number}
 * [deltaHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes] The maximum
 * allowed percentage of upgrade domain nodes health degradation allowed during
 * cluster upgrades.
 * The delta is measured between the state of the upgrade domain nodes at the
 * beginning of upgrade and the state of the upgrade domain nodes at the time
 * of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion for all
 * completed upgrade domains to make sure the state of the upgrade domains is
 * within tolerated limits.
 * @member {number} [deltaHealthPolicy.maxPercentDeltaUnhealthyApplications]
 * The maximum allowed percentage of applications health degradation allowed
 * during cluster upgrades.
 * The delta is measured between the state of the applications at the beginning
 * of upgrade and the state of the applications at the time of the health
 * evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits. System
 * services are not included in this.
 * @member {array} [deltaHealthPolicy.applicationDeltaHealthPolicies] Defines
 * the application delta health policy map used to evaluate the health of an
 * application or one of its child entities when upgrading the cluster.
 */
export interface ClusterUpgradePolicy {
  forceRestart?: boolean;
  upgradeReplicaSetCheckTimeout: string;
  healthCheckWaitDuration: string;
  healthCheckStableDuration: string;
  healthCheckRetryTimeout: string;
  upgradeTimeout: string;
  upgradeDomainTimeout: string;
  healthPolicy: ClusterHealthPolicy;
  deltaHealthPolicy?: ClusterUpgradeDeltaHealthPolicy;
}

/**
 * @class
 * Initializes a new instance of the Resource class.
 * @constructor
 * The resource model definition.
 *
 * @member {string} [id] Azure resource identifier.
 * @member {string} [name] Azure resource name.
 * @member {string} [type] Azure resource type.
 * @member {string} location Azure resource location.
 * @member {object} [tags] Azure resource tags.
 */
export interface Resource extends BaseResource {
  readonly id?: string;
  readonly name?: string;
  readonly type?: string;
  location: string;
  tags?: { [propertyName: string]: string };
}

/**
 * @class
 * Initializes a new instance of the Cluster class.
 * @constructor
 * The cluster resource
 *
 *
 * @member {array} [addOnFeatures] The list of add-on features to enable in the
 * cluster.
 * @member {array} [availableClusterVersions] The Service Fabric runtime
 * versions available for this cluster.
 * @member {object} [azureActiveDirectory] The AAD authentication settings of
 * the cluster.
 * @member {string} [azureActiveDirectory.tenantId] Azure active directory
 * tenant id.
 * @member {string} [azureActiveDirectory.clusterApplication] Azure active
 * directory cluster application id.
 * @member {string} [azureActiveDirectory.clientApplication] Azure active
 * directory client application id.
 * @member {object} [certificate] The certificate to use for securing the
 * cluster. The certificate provided will be used for node to node security
 * within the cluster, SSL certificate for cluster management endpoint and
 * default admin client.
 * @member {string} [certificate.thumbprint] Thumbprint of the primary
 * certificate.
 * @member {string} [certificate.thumbprintSecondary] Thumbprint of the
 * secondary certificate.
 * @member {string} [certificate.x509StoreName] The local certificate store
 * location. Possible values include: 'AddressBook', 'AuthRoot',
 * 'CertificateAuthority', 'Disallowed', 'My', 'Root', 'TrustedPeople',
 * 'TrustedPublisher'
 * @member {object} [certificateCommonNames] Describes a list of server
 * certificates referenced by common name that are used to secure the cluster.
 * @member {array} [certificateCommonNames.commonNames] The list of server
 * certificates referenced by common name that are used to secure the cluster.
 * @member {string} [certificateCommonNames.x509StoreName] The local
 * certificate store location. Possible values include: 'AddressBook',
 * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
 * 'TrustedPeople', 'TrustedPublisher'
 * @member {array} [clientCertificateCommonNames] The list of client
 * certificates referenced by common name that are allowed to manage the
 * cluster.
 * @member {array} [clientCertificateThumbprints] The list of client
 * certificates referenced by thumbprint that are allowed to manage the
 * cluster.
 * @member {string} [clusterCodeVersion] The Service Fabric runtime version of
 * the cluster. This property can only by set the user when **upgradeMode** is
 * set to 'Manual'. To get list of available Service Fabric versions for new
 * clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of
 * available version for existing clusters use **availableClusterVersions**.
 * @member {string} [clusterEndpoint] The Azure Resource Provider endpoint. A
 * system service in the cluster connects to this  endpoint.
 * @member {string} [clusterId] A service generated unique identifier for the
 * cluster resource.
 * @member {string} [clusterState] The current state of the cluster.
 *
 * - WaitingForNodes - Indicates that the cluster resource is created and the
 * resource provider is waiting for Service Fabric VM extension to boot up and
 * report to it.
 * - Deploying - Indicates that the Service Fabric runtime is being installed
 * on the VMs. Cluster resource will be in this state until the cluster boots
 * up and system services are up.
 * - BaselineUpgrade - Indicates that the cluster is upgrading to establishes
 * the cluster version. This upgrade is automatically initiated when the
 * cluster boots up for the first time.
 * - UpdatingUserConfiguration - Indicates that the cluster is being upgraded
 * with the user provided configuration.
 * - UpdatingUserCertificate - Indicates that the cluster is being upgraded
 * with the user provided certificate.
 * - UpdatingInfrastructure - Indicates that the cluster is being upgraded with
 * the latest Service Fabric runtime version. This happens only when the
 * **upgradeMode** is set to 'Automatic'.
 * - EnforcingClusterVersion - Indicates that cluster is on a different version
 * than expected and the cluster is being upgraded to the expected version.
 * - UpgradeServiceUnreachable - Indicates that the system service in the
 * cluster is no longer polling the Resource Provider. Clusters in this state
 * cannot be managed by the Resource Provider.
 * - AutoScale - Indicates that the ReliabilityLevel of the cluster is being
 * adjusted.
 * - Ready - Indicates that the cluster is in a stable state.
 * . Possible values include: 'WaitingForNodes', 'Deploying',
 * 'BaselineUpgrade', 'UpdatingUserConfiguration', 'UpdatingUserCertificate',
 * 'UpdatingInfrastructure', 'EnforcingClusterVersion',
 * 'UpgradeServiceUnreachable', 'AutoScale', 'Ready'
 * @member {object} [diagnosticsStorageAccountConfig] The storage account
 * information for storing Service Fabric diagnostic logs.
 * @member {string} [diagnosticsStorageAccountConfig.storageAccountName] The
 * Azure storage account name.
 * @member {string} [diagnosticsStorageAccountConfig.protectedAccountKeyName]
 * The protected diagnostics storage key name.
 * @member {string} [diagnosticsStorageAccountConfig.blobEndpoint] The blob
 * endpoint of the azure storage account.
 * @member {string} [diagnosticsStorageAccountConfig.queueEndpoint] The queue
 * endpoint of the azure storage account.
 * @member {string} [diagnosticsStorageAccountConfig.tableEndpoint] The table
 * endpoint of the azure storage account.
 * @member {array} [fabricSettings] The list of custom fabric settings to
 * configure the cluster.
 * @member {string} managementEndpoint The http management endpoint of the
 * cluster.
 * @member {array} nodeTypes The list of node types in the cluster.
 * @member {string} [provisioningState] The provisioning state of the cluster
 * resource. Possible values include: 'Updating', 'Succeeded', 'Failed',
 * 'Canceled'
 * @member {string} [reliabilityLevel] The reliability level sets the replica
 * set size of system services. Learn about
 * [ReliabilityLevel](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-capacity).
 *
 * - None - Run the System services with a target replica set count of 1. This
 * should only be used for test clusters.
 * - Bronze - Run the System services with a target replica set count of 3.
 * This should only be used for test clusters.
 * - Silver - Run the System services with a target replica set count of 5.
 * - Gold - Run the System services with a target replica set count of 7.
 * - Platinum - Run the System services with a target replica set count of 9.
 * . Possible values include: 'None', 'Bronze', 'Silver', 'Gold', 'Platinum'
 * @member {object} [reverseProxyCertificate] The server certificate used by
 * reverse proxy.
 * @member {string} [reverseProxyCertificate.thumbprint] Thumbprint of the
 * primary certificate.
 * @member {string} [reverseProxyCertificate.thumbprintSecondary] Thumbprint of
 * the secondary certificate.
 * @member {string} [reverseProxyCertificate.x509StoreName] The local
 * certificate store location. Possible values include: 'AddressBook',
 * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
 * 'TrustedPeople', 'TrustedPublisher'
 * @member {object} [reverseProxyCertificateCommonNames] Describes a list of
 * server certificates referenced by common name that are used to secure the
 * cluster.
 * @member {array} [reverseProxyCertificateCommonNames.commonNames] The list of
 * server certificates referenced by common name that are used to secure the
 * cluster.
 * @member {string} [reverseProxyCertificateCommonNames.x509StoreName] The
 * local certificate store location. Possible values include: 'AddressBook',
 * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
 * 'TrustedPeople', 'TrustedPublisher'
 * @member {object} [upgradeDescription] The policy to use when upgrading the
 * cluster.
 * @member {boolean} [upgradeDescription.forceRestart] If true, then processes
 * are forcefully restarted during upgrade even when the code version has not
 * changed (the upgrade only changes configuration or data).
 * @member {string} [upgradeDescription.upgradeReplicaSetCheckTimeout] The
 * maximum amount of time to block processing of an upgrade domain and revent
 * loss of availability when there are unexpected issues. When this timeout
 * expires, processing of the upgrade domain will proceed regardless of
 * availability loss issues. The timeout is reset at the start of each upgrade
 * domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {string} [upgradeDescription.healthCheckWaitDuration] The length of
 * time to wait after completing an upgrade domain before performing health
 * checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {string} [upgradeDescription.healthCheckStableDuration] The amount
 * of time that the application or cluster must remain healthy before the
 * upgrade proceeds to the next upgrade domain. The duration can be in either
 * hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {string} [upgradeDescription.healthCheckRetryTimeout] The amount of
 * time to retry health evaluation when the application or cluster is unhealthy
 * before the upgrade rolls back. The timeout can be in either hh:mm:ss or in
 * d.hh:mm:ss.ms format.
 * @member {string} [upgradeDescription.upgradeTimeout] The amount of time the
 * overall upgrade has to complete before the upgrade rolls back. The timeout
 * can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {string} [upgradeDescription.upgradeDomainTimeout] The amount of
 * time each upgrade domain has to complete before the upgrade rolls back. The
 * timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {object} [upgradeDescription.healthPolicy] The cluster health policy
 * used when upgrading the cluster.
 * @member {number} [upgradeDescription.healthPolicy.maxPercentUnhealthyNodes]
 * The maximum allowed percentage of unhealthy nodes before reporting an error.
 * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @member {number}
 * [upgradeDescription.healthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @member {array} [upgradeDescription.healthPolicy.applicationHealthPolicies]
 * Defines the application health policy map used to evaluate the health of an
 * application or one of its children entities.
 * @member {object} [upgradeDescription.deltaHealthPolicy] The cluster delta
 * health policy used when upgrading the cluster.
 * @member {number}
 * [upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyNodes] The
 * maximum allowed percentage of nodes health degradation allowed during
 * cluster upgrades.
 * The delta is measured between the state of the nodes at the beginning of
 * upgrade and the state of the nodes at the time of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits.
 * @member {number}
 * [upgradeDescription.deltaHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
 * The maximum allowed percentage of upgrade domain nodes health degradation
 * allowed during cluster upgrades.
 * The delta is measured between the state of the upgrade domain nodes at the
 * beginning of upgrade and the state of the upgrade domain nodes at the time
 * of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion for all
 * completed upgrade domains to make sure the state of the upgrade domains is
 * within tolerated limits.
 * @member {number}
 * [upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyApplications]
 * The maximum allowed percentage of applications health degradation allowed
 * during cluster upgrades.
 * The delta is measured between the state of the applications at the beginning
 * of upgrade and the state of the applications at the time of the health
 * evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits. System
 * services are not included in this.
 * @member {array}
 * [upgradeDescription.deltaHealthPolicy.applicationDeltaHealthPolicies]
 * Defines the application delta health policy map used to evaluate the health
 * of an application or one of its child entities when upgrading the cluster.
 * @member {string} [upgradeMode] The upgrade mode of the cluster when new
 * Service Fabric runtime version is available.
 *
 * - Automatic - The cluster will be automatically upgraded to the latest
 * Service Fabric runtime version as soon as it is available.
 * - Manual - The cluster will not be automatically upgraded to the latest
 * Service Fabric runtime version. The cluster is upgraded by setting the
 * **clusterCodeVersion** property in the cluster resource.
 * . Possible values include: 'Automatic', 'Manual'
 * @member {string} [vmImage] The VM image VMSS has been configured with.
 * Generic names such as Windows or Linux can be used.
 */
export interface Cluster extends Resource {
  addOnFeatures?: string[];
  readonly availableClusterVersions?: ClusterVersionDetails[];
  azureActiveDirectory?: AzureActiveDirectory;
  certificate?: CertificateDescription;
  certificateCommonNames?: ServerCertificateCommonNames;
  clientCertificateCommonNames?: ClientCertificateCommonName[];
  clientCertificateThumbprints?: ClientCertificateThumbprint[];
  clusterCodeVersion?: string;
  readonly clusterEndpoint?: string;
  readonly clusterId?: string;
  readonly clusterState?: string;
  diagnosticsStorageAccountConfig?: DiagnosticsStorageAccountConfig;
  fabricSettings?: SettingsSectionDescription[];
  managementEndpoint: string;
  nodeTypes: NodeTypeDescription[];
  readonly provisioningState?: string;
  reliabilityLevel?: string;
  reverseProxyCertificate?: CertificateDescription;
  reverseProxyCertificateCommonNames?: ServerCertificateCommonNames;
  upgradeDescription?: ClusterUpgradePolicy;
  upgradeMode?: string;
  vmImage?: string;
}

/**
 * @class
 * Initializes a new instance of the ClusterCodeVersionsResult class.
 * @constructor
 * The result of the ServiceFabric runtime versions
 *
 * @member {string} [id] The identification of the result
 * @member {string} [name] The name of the result
 * @member {string} [type] The result resource type
 * @member {string} [codeVersion] The Service Fabric runtime version of the
 * cluster.
 * @member {string} [supportExpiryUtc] The date of expiry of support of the
 * version.
 * @member {string} [environment] Indicates if this version is for Windows or
 * Linux operating system. Possible values include: 'Windows', 'Linux'
 */
export interface ClusterCodeVersionsResult {
  id?: string;
  name?: string;
  type?: string;
  codeVersion?: string;
  supportExpiryUtc?: string;
  environment?: string;
}

/**
 * @class
 * Initializes a new instance of the ClusterCodeVersionsListResult class.
 * @constructor
 * The list results of the ServiceFabric runtime versions.
 *
 * @member {array} [value]
 * @member {string} [nextLink] The URL to use for getting the next set of
 * results.
 */
export interface ClusterCodeVersionsListResult {
  value?: ClusterCodeVersionsResult[];
  nextLink?: string;
}

/**
 * @class
 * Initializes a new instance of the ClusterListResult class.
 * @constructor
 * Cluster list results
 *
 * @member {array} [value]
 * @member {string} [nextLink] The URL to use for getting the next set of
 * results.
 */
export interface ClusterListResult {
  value?: Cluster[];
  nextLink?: string;
}

/**
 * @class
 * Initializes a new instance of the ClusterUpdateParameters class.
 * @constructor
 * Cluster update request
 *
 * @member {array} [addOnFeatures] The list of add-on features to enable in the
 * cluster.
 * @member {object} [certificate] The certificate to use for securing the
 * cluster. The certificate provided will be used for  node to node security
 * within the cluster, SSL certificate for cluster management endpoint and
 * default  admin client.
 * @member {string} [certificate.thumbprint] Thumbprint of the primary
 * certificate.
 * @member {string} [certificate.thumbprintSecondary] Thumbprint of the
 * secondary certificate.
 * @member {string} [certificate.x509StoreName] The local certificate store
 * location. Possible values include: 'AddressBook', 'AuthRoot',
 * 'CertificateAuthority', 'Disallowed', 'My', 'Root', 'TrustedPeople',
 * 'TrustedPublisher'
 * @member {object} [certificateCommonNames] Describes a list of server
 * certificates referenced by common name that are used to secure the cluster.
 * @member {array} [certificateCommonNames.commonNames] The list of server
 * certificates referenced by common name that are used to secure the cluster.
 * @member {string} [certificateCommonNames.x509StoreName] The local
 * certificate store location. Possible values include: 'AddressBook',
 * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
 * 'TrustedPeople', 'TrustedPublisher'
 * @member {array} [clientCertificateCommonNames] The list of client
 * certificates referenced by common name that are allowed to manage the
 * cluster. This will overwrite the existing list.
 * @member {array} [clientCertificateThumbprints] The list of client
 * certificates referenced by thumbprint that are allowed to manage the
 * cluster. This will overwrite the existing list.
 * @member {string} [clusterCodeVersion] The Service Fabric runtime version of
 * the cluster. This property can only by set the user when **upgradeMode** is
 * set to 'Manual'. To get list of available Service Fabric versions for new
 * clusters use [ClusterVersion API](./ClusterVersion.md). To get the list of
 * available version for existing clusters use **availableClusterVersions**.
 * @member {array} [fabricSettings] The list of custom fabric settings to
 * configure the cluster. This will overwrite the existing list.
 * @member {array} [nodeTypes] The list of node types in the cluster. This will
 * overwrite the existing list.
 * @member {string} [reliabilityLevel] The reliability level sets the replica
 * set size of system services. Learn about
 * [ReliabilityLevel](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-capacity).
 *
 * - None - Run the System services with a target replica set count of 1. This
 * should only be used for test clusters.
 * - Bronze - Run the System services with a target replica set count of 3.
 * This should only be used for test clusters.
 * - Silver - Run the System services with a target replica set count of 5.
 * - Gold - Run the System services with a target replica set count of 7.
 * - Platinum - Run the System services with a target replica set count of 9.
 * . Possible values include: 'None', 'Bronze', 'Silver', 'Gold', 'Platinum'
 * @member {object} [reverseProxyCertificate] The server certificate used by
 * reverse proxy.
 * @member {string} [reverseProxyCertificate.thumbprint] Thumbprint of the
 * primary certificate.
 * @member {string} [reverseProxyCertificate.thumbprintSecondary] Thumbprint of
 * the secondary certificate.
 * @member {string} [reverseProxyCertificate.x509StoreName] The local
 * certificate store location. Possible values include: 'AddressBook',
 * 'AuthRoot', 'CertificateAuthority', 'Disallowed', 'My', 'Root',
 * 'TrustedPeople', 'TrustedPublisher'
 * @member {object} [upgradeDescription] The policy to use when upgrading the
 * cluster.
 * @member {boolean} [upgradeDescription.forceRestart] If true, then processes
 * are forcefully restarted during upgrade even when the code version has not
 * changed (the upgrade only changes configuration or data).
 * @member {string} [upgradeDescription.upgradeReplicaSetCheckTimeout] The
 * maximum amount of time to block processing of an upgrade domain and revent
 * loss of availability when there are unexpected issues. When this timeout
 * expires, processing of the upgrade domain will proceed regardless of
 * availability loss issues. The timeout is reset at the start of each upgrade
 * domain. The timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {string} [upgradeDescription.healthCheckWaitDuration] The length of
 * time to wait after completing an upgrade domain before performing health
 * checks. The duration can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {string} [upgradeDescription.healthCheckStableDuration] The amount
 * of time that the application or cluster must remain healthy before the
 * upgrade proceeds to the next upgrade domain. The duration can be in either
 * hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {string} [upgradeDescription.healthCheckRetryTimeout] The amount of
 * time to retry health evaluation when the application or cluster is unhealthy
 * before the upgrade rolls back. The timeout can be in either hh:mm:ss or in
 * d.hh:mm:ss.ms format.
 * @member {string} [upgradeDescription.upgradeTimeout] The amount of time the
 * overall upgrade has to complete before the upgrade rolls back. The timeout
 * can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {string} [upgradeDescription.upgradeDomainTimeout] The amount of
 * time each upgrade domain has to complete before the upgrade rolls back. The
 * timeout can be in either hh:mm:ss or in d.hh:mm:ss.ms format.
 * @member {object} [upgradeDescription.healthPolicy] The cluster health policy
 * used when upgrading the cluster.
 * @member {number} [upgradeDescription.healthPolicy.maxPercentUnhealthyNodes]
 * The maximum allowed percentage of unhealthy nodes before reporting an error.
 * For example, to allow 10% of nodes to be unhealthy, this value would be 10.
 *
 * The percentage represents the maximum tolerated percentage of nodes that can
 * be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy node, the
 * health is evaluated as Warning.
 * The percentage is calculated by dividing the number of unhealthy nodes over
 * the total number of nodes in the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 *
 * In large clusters, some nodes will always be down or out for repairs, so
 * this percentage should be configured to tolerate that.
 * @member {number}
 * [upgradeDescription.healthPolicy.maxPercentUnhealthyApplications] The
 * maximum allowed percentage of unhealthy applications before reporting an
 * error. For example, to allow 10% of applications to be unhealthy, this value
 * would be 10.
 *
 * The percentage represents the maximum tolerated percentage of applications
 * that can be unhealthy before the cluster is considered in error.
 * If the percentage is respected but there is at least one unhealthy
 * application, the health is evaluated as Warning.
 * This is calculated by dividing the number of unhealthy applications over the
 * total number of application instances in the cluster, excluding applications
 * of application types that are included in the
 * ApplicationTypeHealthPolicyMap.
 * The computation rounds up to tolerate one failure on small numbers of
 * applications. Default percentage is zero.
 * @member {array} [upgradeDescription.healthPolicy.applicationHealthPolicies]
 * Defines the application health policy map used to evaluate the health of an
 * application or one of its children entities.
 * @member {object} [upgradeDescription.deltaHealthPolicy] The cluster delta
 * health policy used when upgrading the cluster.
 * @member {number}
 * [upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyNodes] The
 * maximum allowed percentage of nodes health degradation allowed during
 * cluster upgrades.
 * The delta is measured between the state of the nodes at the beginning of
 * upgrade and the state of the nodes at the time of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits.
 * @member {number}
 * [upgradeDescription.deltaHealthPolicy.maxPercentUpgradeDomainDeltaUnhealthyNodes]
 * The maximum allowed percentage of upgrade domain nodes health degradation
 * allowed during cluster upgrades.
 * The delta is measured between the state of the upgrade domain nodes at the
 * beginning of upgrade and the state of the upgrade domain nodes at the time
 * of the health evaluation.
 * The check is performed after every upgrade domain upgrade completion for all
 * completed upgrade domains to make sure the state of the upgrade domains is
 * within tolerated limits.
 * @member {number}
 * [upgradeDescription.deltaHealthPolicy.maxPercentDeltaUnhealthyApplications]
 * The maximum allowed percentage of applications health degradation allowed
 * during cluster upgrades.
 * The delta is measured between the state of the applications at the beginning
 * of upgrade and the state of the applications at the time of the health
 * evaluation.
 * The check is performed after every upgrade domain upgrade completion to make
 * sure the global state of the cluster is within tolerated limits. System
 * services are not included in this.
 * @member {array}
 * [upgradeDescription.deltaHealthPolicy.applicationDeltaHealthPolicies]
 * Defines the application delta health policy map used to evaluate the health
 * of an application or one of its child entities when upgrading the cluster.
 * @member {string} [upgradeMode] The upgrade mode of the cluster when new
 * Service Fabric runtime version is available.
 *
 * - Automatic - The cluster will be automatically upgraded to the latest
 * Service Fabric runtime version as soon as it is available.
 * - Manual - The cluster will not be automatically upgraded to the latest
 * Service Fabric runtime version. The cluster is upgraded by setting the
 * **clusterCodeVersion** property in the cluster resource.
 * . Possible values include: 'Automatic', 'Manual'
 * @member {object} [tags] Cluster update parameters
 */
export interface ClusterUpdateParameters {
  addOnFeatures?: string[];
  certificate?: CertificateDescription;
  certificateCommonNames?: ServerCertificateCommonNames;
  clientCertificateCommonNames?: ClientCertificateCommonName[];
  clientCertificateThumbprints?: ClientCertificateThumbprint[];
  clusterCodeVersion?: string;
  fabricSettings?: SettingsSectionDescription[];
  nodeTypes?: NodeTypeDescription[];
  reliabilityLevel?: string;
  reverseProxyCertificate?: CertificateDescription;
  upgradeDescription?: ClusterUpgradePolicy;
  upgradeMode?: string;
  tags?: { [propertyName: string]: string };
}

/**
 * @class
 * Initializes a new instance of the ErrorModel class.
 * @constructor
 * The error details.
 *
 * @member {string} [code] The error code.
 * @member {string} [message] The error message.
 */
export interface ErrorModel {
  code?: string;
  message?: string;
}

/**
 * @class
 * Initializes a new instance of the OperationResult class.
 * @constructor
 * Available operation list result
 *
 * @member {string} [name] The name of the operation.
 * @member {object} [display] The object that represents the operation.
 * @member {string} [display.provider] The name of the provider.
 * @member {string} [display.resource] The resource on which the operation is
 * performed
 * @member {string} [display.operation] The operation that can be performed.
 * @member {string} [display.description] Operation description
 * @member {string} [origin] Origin result
 * @member {string} [nextLink] The URL to use for getting the next set of
 * results.
 */
export interface OperationResult {
  name?: string;
  display?: AvailableOperationDisplay;
  origin?: string;
  nextLink?: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationMetricDescription class.
 * @constructor
 * Describes capacity information for a custom resource balancing metric. This
 * can be used to limit the total consumption of this metric by the services of
 * this application.
 *
 *
 * @member {string} [name] The name of the metric.
 * @member {number} [maximumCapacity] The maximum node capacity for Service
 * Fabric application.
 * This is the maximum Load for an instance of this application on a single
 * node. Even if the capacity of node is greater than this value, Service
 * Fabric will limit the total load of services within the application on each
 * node to this value.
 * If set to zero, capacity for this metric is unlimited on each node.
 * When creating a new application with application capacity defined, the
 * product of MaximumNodes and this value must always be smaller than or equal
 * to TotalApplicationCapacity.
 * When updating existing application with application capacity, the product of
 * MaximumNodes and this value must always be smaller than or equal to
 * TotalApplicationCapacity.
 * @member {number} [reservationCapacity] The node reservation capacity for
 * Service Fabric application.
 * This is the amount of load which is reserved on nodes which have instances
 * of this application.
 * If MinimumNodes is specified, then the product of these values will be the
 * capacity reserved in the cluster for the application.
 * If set to zero, no capacity is reserved for this metric.
 * When setting application capacity or when updating application capacity;
 * this value must be smaller than or equal to MaximumCapacity for each metric.
 * @member {number} [totalApplicationCapacity] The total metric capacity for
 * Service Fabric application.
 * This is the total metric capacity for this application in the cluster.
 * Service Fabric will try to limit the sum of loads of services within the
 * application to this value.
 * When creating a new application with application capacity defined, the
 * product of MaximumNodes and MaximumCapacity must always be smaller than or
 * equal to this value.
 */
export interface ApplicationMetricDescription {
  name?: string;
  maximumCapacity?: number;
  reservationCapacity?: number;
  totalApplicationCapacity?: number;
}

/**
 * @class
 * Initializes a new instance of the ApplicationParameter class.
 * @constructor
 * Describes an application parameter override to be applied when creating or
 * upgrading an application.
 *
 * @member {string} key The name of the parameter.
 * @member {string} value The value of the parameter.
 */
export interface ApplicationParameter {
  key: string;
  value: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceCorrelationDescription class.
 * @constructor
 * Creates a particular correlation between services.
 *
 * @member {string} scheme The ServiceCorrelationScheme which describes the
 * relationship between this service and the service specified via ServiceName.
 * Possible values include: 'Invalid', 'Affinity', 'AlignedAffinity',
 * 'NonAlignedAffinity'
 * @member {string} serviceName The name of the service that the correlation
 * relationship is established with.
 */
export interface ServiceCorrelationDescription {
  scheme: string;
  serviceName: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceLoadMetricDescription class.
 * @constructor
 * Specifies a metric to load balance a service during runtime.
 *
 * @member {string} name The name of the metric. If the service chooses to
 * report load during runtime, the load metric name should match the name that
 * is specified in Name exactly. Note that metric names are case sensitive.
 * @member {string} [weight] The service load metric relative weight, compared
 * to other metrics configured for this service, as a number. Possible values
 * include: 'Zero', 'Low', 'Medium', 'High'
 * @member {number} [primaryDefaultLoad] Used only for Stateful services. The
 * default amount of load, as a number, that this service creates for this
 * metric when it is a Primary replica.
 * @member {number} [secondaryDefaultLoad] Used only for Stateful services. The
 * default amount of load, as a number, that this service creates for this
 * metric when it is a Secondary replica.
 * @member {number} [defaultLoad] Used only for Stateless services. The default
 * amount of load, as a number, that this service creates for this metric.
 */
export interface ServiceLoadMetricDescription {
  name: string;
  weight?: string;
  primaryDefaultLoad?: number;
  secondaryDefaultLoad?: number;
  defaultLoad?: number;
}

/**
 * @class
 * Initializes a new instance of the ServicePlacementPolicyDescription class.
 * @constructor
 * Describes the policy to be used for placement of a Service Fabric service.
 *
 * @member {string} type Polymorphic Discriminator
 */
export interface ServicePlacementPolicyDescription {
  type: string;
}

/**
 * @class
 * Initializes a new instance of the PartitionSchemeDescription class.
 * @constructor
 * Describes how the service is partitioned.
 *
 * @member {string} partitionScheme Polymorphic Discriminator
 */
export interface PartitionSchemeDescription {
  partitionScheme: string;
}

/**
 * @class
 * Initializes a new instance of the NamedPartitionSchemeDescription class.
 * @constructor
 * Describes the named partition scheme of the service.
 *
 * @member {number} count The number of partitions.
 * @member {array} names Array of size specified by the ‘Count’ parameter, for
 * the names of the partitions.
 */
export interface NamedPartitionSchemeDescription extends PartitionSchemeDescription {
  count: number;
  names: string[];
}

/**
 * @class
 * Initializes a new instance of the SingletonPartitionSchemeDescription class.
 * @constructor
 * Describes the partition scheme of a singleton-partitioned, or
 * non-partitioned service.
 *
 */
export interface SingletonPartitionSchemeDescription extends PartitionSchemeDescription {
}

/**
 * @class
 * Initializes a new instance of the UniformInt64RangePartitionSchemeDescription class.
 * @constructor
 * Describes a partitioning scheme where an integer range is allocated evenly
 * across a number of partitions.
 *
 * @member {number} count The number of partitions.
 * @member {string} lowKey String indicating the lower bound of the partition
 * key range that
 * should be split between the partition ‘Count’
 * @member {string} highKey String indicating the upper bound of the partition
 * key range that
 * should be split between the partition ‘Count’
 */
export interface UniformInt64RangePartitionSchemeDescription extends PartitionSchemeDescription {
  count: number;
  lowKey: string;
  highKey: string;
}

/**
 * @class
 * Initializes a new instance of the ProxyResource class.
 * @constructor
 * The resource model definition for proxy-only resource.
 *
 * @member {string} [id] Azure resource identifier.
 * @member {string} [name] Azure resource name.
 * @member {string} [type] Azure resource type.
 * @member {string} [location] Azure resource location.
 */
export interface ProxyResource extends BaseResource {
  readonly id?: string;
  readonly name?: string;
  readonly type?: string;
  location?: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationResource class.
 * @constructor
 * The application resource.
 *
 * @member {string} [typeVersion] The version of the application type as
 * defined in the application manifest.
 * @member {array} [parameters] List of application parameters with overridden
 * values from their default values specified in the application manifest.
 * @member {object} [upgradePolicy] Describes the policy for a monitored
 * application upgrade.
 * @member {number} [upgradePolicy.upgradeReplicaSetCheckTimeout] The maximum
 * amount of time to block processing of an upgrade domain and prevent loss of
 * availability when there are unexpected issues. When this timeout expires,
 * processing of the upgrade domain will proceed regardless of availability
 * loss issues. The timeout is reset at the start of each upgrade domain. Valid
 * values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
 * @member {boolean} [upgradePolicy.forceRestart] If true, then processes are
 * forcefully restarted during upgrade even when the code version has not
 * changed (the upgrade only changes configuration or data).
 * @member {object} [upgradePolicy.rollingUpgradeMonitoringPolicy] The policy
 * used for monitoring the application upgrade
 * @member {string}
 * [upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckWaitDuration] The
 * amount of time to wait after completing an upgrade domain before applying
 * health policies. It is first interpreted as a string representing an ISO
 * 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @member {string}
 * [upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckStableDuration] The
 * amount of time that the application or cluster must remain healthy before
 * the upgrade proceeds to the next upgrade domain. It is first interpreted as
 * a string representing an ISO 8601 duration. If that fails, then it is
 * interpreted as a number representing the total number of milliseconds.
 * @member {string}
 * [upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckRetryTimeout] The
 * amount of time to retry health evaluation when the application or cluster is
 * unhealthy before FailureAction is executed. It is first interpreted as a
 * string representing an ISO 8601 duration. If that fails, then it is
 * interpreted as a number representing the total number of milliseconds.
 * @member {string}
 * [upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeTimeout] The amount of
 * time the overall upgrade has to complete before FailureAction is executed.
 * It is first interpreted as a string representing an ISO 8601 duration. If
 * that fails, then it is interpreted as a number representing the total number
 * of milliseconds.
 * @member {string}
 * [upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeDomainTimeout] The
 * amount of time each upgrade domain has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @member {object} [upgradePolicy.applicationHealthPolicy] Defines a health
 * policy used to evaluate the health of an application or one of its children
 * entities.
 * @member {object}
 * [upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The
 * health policy used by default to evaluate the health of a service type.
 * @member {number}
 * [upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum percentage of services allowed to be unhealthy before your
 * application is considered in error.
 * @member {array}
 * [upgradePolicy.applicationHealthPolicy.serviceTypeHealthPolicies] The map
 * with service type health policy per service type name. The map is empty by
 * default.
 * @member {boolean}
 * [upgradePolicy.applicationHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @member {number}
 * [upgradePolicy.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 * @member {object}
 * [upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy1] The
 * health policy used by default to evaluate the health of a service type.
 * @member {number}
 * [upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy1.maxPercentUnhealthyServices]
 * The maximum percentage of services allowed to be unhealthy before your
 * application is considered in error.
 * @member {array}
 * [upgradePolicy.applicationHealthPolicy.serviceTypeHealthPolicyMap] The map
 * with service type health policy per service type name. The map is empty by
 * default.
 * @member {number} [minimumNodes] The minimum number of nodes where Service
 * Fabric will reserve capacity for this application. Note that this does not
 * mean that the services of this application will be placed on all of those
 * nodes. If this property is set to zero, no capacity will be reserved. The
 * value of this property cannot be more than the value of the MaximumNodes
 * property.
 * @member {number} [maximumNodes] The maximum number of nodes where Service
 * Fabric will reserve capacity for this application. Note that this does not
 * mean that the services of this application will be placed on all of those
 * nodes. By default, the value of this property is zero and it means that the
 * services can be placed on any node. Default value: 0 .
 * @member {boolean} [removeApplicationCapacity] Remove the current application
 * capacity settings.
 * @member {array} [metrics] List of application capacity metric description.
 * @member {string} [provisioningState] The current deployment or provisioning
 * state, which only appears in the response
 * @member {string} [typeName] The application type name as defined in the
 * application manifest.
 */
export interface ApplicationResource extends ProxyResource {
  typeVersion?: string;
  parameters?: ApplicationParameter[];
  upgradePolicy?: ApplicationUpgradePolicy;
  minimumNodes?: number;
  maximumNodes?: number;
  removeApplicationCapacity?: boolean;
  metrics?: ApplicationMetricDescription[];
  readonly provisioningState?: string;
  typeName?: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationResourceList class.
 * @constructor
 * The list of application resources.
 *
 * @member {array} [value]
 */
export interface ApplicationResourceList {
  value?: ApplicationResource[];
}

/**
 * @class
 * Initializes a new instance of the RollingUpgradeMonitoringPolicy class.
 * @constructor
 * The policy used for monitoring the application upgrade
 *
 * @member {string} [healthCheckWaitDuration] The amount of time to wait after
 * completing an upgrade domain before applying health policies. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @member {string} [healthCheckStableDuration] The amount of time that the
 * application or cluster must remain healthy before the upgrade proceeds to
 * the next upgrade domain. It is first interpreted as a string representing an
 * ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @member {string} [healthCheckRetryTimeout] The amount of time to retry
 * health evaluation when the application or cluster is unhealthy before
 * FailureAction is executed. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @member {string} [upgradeTimeout] The amount of time the overall upgrade has
 * to complete before FailureAction is executed. It is first interpreted as a
 * string representing an ISO 8601 duration. If that fails, then it is
 * interpreted as a number representing the total number of milliseconds.
 * @member {string} [upgradeDomainTimeout] The amount of time each upgrade
 * domain has to complete before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 */
export interface RollingUpgradeMonitoringPolicy {
  healthCheckWaitDuration?: string;
  healthCheckStableDuration?: string;
  healthCheckRetryTimeout?: string;
  upgradeTimeout?: string;
  upgradeDomainTimeout?: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationUpgradePolicy class.
 * @constructor
 * Describes the policy for a monitored application upgrade.
 *
 * @member {number} [upgradeReplicaSetCheckTimeout] The maximum amount of time
 * to block processing of an upgrade domain and prevent loss of availability
 * when there are unexpected issues. When this timeout expires, processing of
 * the upgrade domain will proceed regardless of availability loss issues. The
 * timeout is reset at the start of each upgrade domain. Valid values are
 * between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
 * @member {boolean} [forceRestart] If true, then processes are forcefully
 * restarted during upgrade even when the code version has not changed (the
 * upgrade only changes configuration or data).
 * @member {object} [rollingUpgradeMonitoringPolicy] The policy used for
 * monitoring the application upgrade
 * @member {string} [rollingUpgradeMonitoringPolicy.healthCheckWaitDuration]
 * The amount of time to wait after completing an upgrade domain before
 * applying health policies. It is first interpreted as a string representing
 * an ISO 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @member {string} [rollingUpgradeMonitoringPolicy.healthCheckStableDuration]
 * The amount of time that the application or cluster must remain healthy
 * before the upgrade proceeds to the next upgrade domain. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @member {string} [rollingUpgradeMonitoringPolicy.healthCheckRetryTimeout]
 * The amount of time to retry health evaluation when the application or
 * cluster is unhealthy before FailureAction is executed. It is first
 * interpreted as a string representing an ISO 8601 duration. If that fails,
 * then it is interpreted as a number representing the total number of
 * milliseconds.
 * @member {string} [rollingUpgradeMonitoringPolicy.upgradeTimeout] The amount
 * of time the overall upgrade has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @member {string} [rollingUpgradeMonitoringPolicy.upgradeDomainTimeout] The
 * amount of time each upgrade domain has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @member {object} [applicationHealthPolicy] Defines a health policy used to
 * evaluate the health of an application or one of its children entities.
 * @member {object} [applicationHealthPolicy.defaultServiceTypeHealthPolicy]
 * The health policy used by default to evaluate the health of a service type.
 * @member {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum percentage of services allowed to be unhealthy before your
 * application is considered in error.
 * @member {array} [applicationHealthPolicy.serviceTypeHealthPolicies] The map
 * with service type health policy per service type name. The map is empty by
 * default.
 * @member {boolean} [applicationHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @member {number}
 * [applicationHealthPolicy.maxPercentUnhealthyDeployedApplications] The
 * maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 * @member {object} [applicationHealthPolicy.defaultServiceTypeHealthPolicy1]
 * The health policy used by default to evaluate the health of a service type.
 * @member {number}
 * [applicationHealthPolicy.defaultServiceTypeHealthPolicy1.maxPercentUnhealthyServices]
 * The maximum percentage of services allowed to be unhealthy before your
 * application is considered in error.
 * @member {array} [applicationHealthPolicy.serviceTypeHealthPolicyMap] The map
 * with service type health policy per service type name. The map is empty by
 * default.
 */
export interface ApplicationUpgradePolicy {
  upgradeReplicaSetCheckTimeout?: number;
  forceRestart?: boolean;
  rollingUpgradeMonitoringPolicy?: RollingUpgradeMonitoringPolicy;
  applicationHealthPolicy?: ApplicationHealthPolicy;
}

/**
 * @class
 * Initializes a new instance of the ApplicationResourceUpdate class.
 * @constructor
 * The application resource for patch operations.
 *
 * @member {string} [typeVersion] The version of the application type as
 * defined in the application manifest.
 * @member {array} [parameters] List of application parameters with overridden
 * values from their default values specified in the application manifest.
 * @member {object} [upgradePolicy] Describes the policy for a monitored
 * application upgrade.
 * @member {number} [upgradePolicy.upgradeReplicaSetCheckTimeout] The maximum
 * amount of time to block processing of an upgrade domain and prevent loss of
 * availability when there are unexpected issues. When this timeout expires,
 * processing of the upgrade domain will proceed regardless of availability
 * loss issues. The timeout is reset at the start of each upgrade domain. Valid
 * values are between 0 and 42949672925 inclusive. (unsigned 32-bit integer).
 * @member {boolean} [upgradePolicy.forceRestart] If true, then processes are
 * forcefully restarted during upgrade even when the code version has not
 * changed (the upgrade only changes configuration or data).
 * @member {object} [upgradePolicy.rollingUpgradeMonitoringPolicy] The policy
 * used for monitoring the application upgrade
 * @member {string}
 * [upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckWaitDuration] The
 * amount of time to wait after completing an upgrade domain before applying
 * health policies. It is first interpreted as a string representing an ISO
 * 8601 duration. If that fails, then it is interpreted as a number
 * representing the total number of milliseconds.
 * @member {string}
 * [upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckStableDuration] The
 * amount of time that the application or cluster must remain healthy before
 * the upgrade proceeds to the next upgrade domain. It is first interpreted as
 * a string representing an ISO 8601 duration. If that fails, then it is
 * interpreted as a number representing the total number of milliseconds.
 * @member {string}
 * [upgradePolicy.rollingUpgradeMonitoringPolicy.healthCheckRetryTimeout] The
 * amount of time to retry health evaluation when the application or cluster is
 * unhealthy before FailureAction is executed. It is first interpreted as a
 * string representing an ISO 8601 duration. If that fails, then it is
 * interpreted as a number representing the total number of milliseconds.
 * @member {string}
 * [upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeTimeout] The amount of
 * time the overall upgrade has to complete before FailureAction is executed.
 * It is first interpreted as a string representing an ISO 8601 duration. If
 * that fails, then it is interpreted as a number representing the total number
 * of milliseconds.
 * @member {string}
 * [upgradePolicy.rollingUpgradeMonitoringPolicy.upgradeDomainTimeout] The
 * amount of time each upgrade domain has to complete before FailureAction is
 * executed. It is first interpreted as a string representing an ISO 8601
 * duration. If that fails, then it is interpreted as a number representing the
 * total number of milliseconds.
 * @member {object} [upgradePolicy.applicationHealthPolicy] Defines a health
 * policy used to evaluate the health of an application or one of its children
 * entities.
 * @member {object}
 * [upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy] The
 * health policy used by default to evaluate the health of a service type.
 * @member {number}
 * [upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy.maxPercentUnhealthyServices]
 * The maximum percentage of services allowed to be unhealthy before your
 * application is considered in error.
 * @member {array}
 * [upgradePolicy.applicationHealthPolicy.serviceTypeHealthPolicies] The map
 * with service type health policy per service type name. The map is empty by
 * default.
 * @member {boolean}
 * [upgradePolicy.applicationHealthPolicy.considerWarningAsError] Indicates
 * whether warnings are treated with the same severity as errors.
 * @member {number}
 * [upgradePolicy.applicationHealthPolicy.maxPercentUnhealthyDeployedApplications]
 * The maximum allowed percentage of unhealthy deployed applications. Allowed
 * values are Byte values from zero to 100.
 * The percentage represents the maximum tolerated percentage of deployed
 * applications that can be unhealthy before the application is considered in
 * error.
 * This is calculated by dividing the number of unhealthy deployed applications
 * over the number of nodes where the application is currently deployed on in
 * the cluster.
 * The computation rounds up to tolerate one failure on small numbers of nodes.
 * Default percentage is zero.
 * @member {object}
 * [upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy1] The
 * health policy used by default to evaluate the health of a service type.
 * @member {number}
 * [upgradePolicy.applicationHealthPolicy.defaultServiceTypeHealthPolicy1.maxPercentUnhealthyServices]
 * The maximum percentage of services allowed to be unhealthy before your
 * application is considered in error.
 * @member {array}
 * [upgradePolicy.applicationHealthPolicy.serviceTypeHealthPolicyMap] The map
 * with service type health policy per service type name. The map is empty by
 * default.
 * @member {number} [minimumNodes] The minimum number of nodes where Service
 * Fabric will reserve capacity for this application. Note that this does not
 * mean that the services of this application will be placed on all of those
 * nodes. If this property is set to zero, no capacity will be reserved. The
 * value of this property cannot be more than the value of the MaximumNodes
 * property.
 * @member {number} [maximumNodes] The maximum number of nodes where Service
 * Fabric will reserve capacity for this application. Note that this does not
 * mean that the services of this application will be placed on all of those
 * nodes. By default, the value of this property is zero and it means that the
 * services can be placed on any node. Default value: 0 .
 * @member {boolean} [removeApplicationCapacity] Remove the current application
 * capacity settings.
 * @member {array} [metrics] List of application capacity metric description.
 */
export interface ApplicationResourceUpdate extends ProxyResource {
  typeVersion?: string;
  parameters?: ApplicationParameter[];
  upgradePolicy?: ApplicationUpgradePolicy;
  minimumNodes?: number;
  maximumNodes?: number;
  removeApplicationCapacity?: boolean;
  metrics?: ApplicationMetricDescription[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationTypeResource class.
 * @constructor
 * The application type name resource
 *
 * @member {string} [provisioningState] The current deployment or provisioning
 * state, which only appears in the response.
 */
export interface ApplicationTypeResource extends ProxyResource {
  readonly provisioningState?: string;
}

/**
 * @class
 * Initializes a new instance of the ApplicationTypeResourceList class.
 * @constructor
 * The list of application type names.
 *
 * @member {array} [value]
 */
export interface ApplicationTypeResourceList {
  value?: ApplicationTypeResource[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationTypeVersionResource class.
 * @constructor
 * An application type version resource for the specified application type name
 * resource.
 *
 * @member {string} [provisioningState] The current deployment or provisioning
 * state, which only appears in the response
 * @member {string} appPackageUrl The URL to the application package
 * @member {array} [defaultParameterList] List of application type parameters
 * that can be overridden when creating or updating the application.
 */
export interface ApplicationTypeVersionResource extends ProxyResource {
  readonly provisioningState?: string;
  appPackageUrl: string;
  readonly defaultParameterList?: ApplicationParameter[];
}

/**
 * @class
 * Initializes a new instance of the ApplicationTypeVersionResourceList class.
 * @constructor
 * The list of application type version resources for the specified application
 * type name resource.
 *
 * @member {array} [value]
 */
export interface ApplicationTypeVersionResourceList {
  value?: ApplicationTypeVersionResource[];
}

/**
 * @class
 * Initializes a new instance of the ServiceResourcePropertiesBase class.
 * @constructor
 * The common service resource properties.
 *
 * @member {string} [placementConstraints] The placement constraints as a
 * string. Placement constraints are boolean expressions on node properties and
 * allow for restricting a service to particular nodes based on the service
 * requirements. For example, to place a service on nodes where NodeType is
 * blue specify the following: "NodeColor == blue)".
 * @member {array} [correlationScheme] A list that describes the correlation of
 * the service with other services.
 * @member {array} [serviceLoadMetrics] The service load metrics is given as an
 * array of ServiceLoadMetricDescription objects.
 * @member {array} [servicePlacementPolicies] A list that describes the
 * correlation of the service with other services.
 * @member {string} [defaultMoveCost] Specifies the move cost for the service.
 * Possible values include: 'Zero', 'Low', 'Medium', 'High'
 */
export interface ServiceResourcePropertiesBase {
  placementConstraints?: string;
  correlationScheme?: ServiceCorrelationDescription[];
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  defaultMoveCost?: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceResourceProperties class.
 * @constructor
 * The service resource properties.
 *
 * @member {string} [provisioningState] The current deployment or provisioning
 * state, which only appears in the response
 * @member {string} [serviceTypeName] The name of the service type
 * @member {object} [partitionDescription] Describes how the service is
 * partitioned.
 * @member {string} [partitionDescription.partitionScheme] Polymorphic
 * Discriminator
 * @member {string} serviceKind Polymorphic Discriminator
 */
export interface ServiceResourceProperties extends ServiceResourcePropertiesBase {
  readonly provisioningState?: string;
  serviceTypeName?: string;
  partitionDescription?: PartitionSchemeDescription;
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceResource class.
 * @constructor
 * The service resource.
 *
 * @member {string} [placementConstraints] The placement constraints as a
 * string. Placement constraints are boolean expressions on node properties and
 * allow for restricting a service to particular nodes based on the service
 * requirements. For example, to place a service on nodes where NodeType is
 * blue specify the following: "NodeColor == blue)".
 * @member {array} [correlationScheme] A list that describes the correlation of
 * the service with other services.
 * @member {array} [serviceLoadMetrics] The service load metrics is given as an
 * array of ServiceLoadMetricDescription objects.
 * @member {array} [servicePlacementPolicies] A list that describes the
 * correlation of the service with other services.
 * @member {string} [defaultMoveCost] Specifies the move cost for the service.
 * Possible values include: 'Zero', 'Low', 'Medium', 'High'
 * @member {string} [provisioningState] The current deployment or provisioning
 * state, which only appears in the response
 * @member {string} [serviceTypeName] The name of the service type
 * @member {object} [partitionDescription] Describes how the service is
 * partitioned.
 * @member {string} [partitionDescription.partitionScheme] Polymorphic
 * Discriminator
 * @member {string} serviceKind Polymorphic Discriminator
 */
export interface ServiceResource extends ProxyResource {
  placementConstraints?: string;
  correlationScheme?: ServiceCorrelationDescription[];
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  defaultMoveCost?: string;
  readonly provisioningState?: string;
  serviceTypeName?: string;
  partitionDescription?: PartitionSchemeDescription;
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceResourceList class.
 * @constructor
 * The list of service resources.
 *
 * @member {array} [value]
 */
export interface ServiceResourceList {
  value?: ServiceResource[];
}

/**
 * @class
 * Initializes a new instance of the ServiceResourceUpdateProperties class.
 * @constructor
 * The service resource properties for patch operations.
 *
 * @member {string} serviceKind Polymorphic Discriminator
 */
export interface ServiceResourceUpdateProperties extends ServiceResourcePropertiesBase {
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the ServiceResourceUpdate class.
 * @constructor
 * The service resource for patch operations.
 *
 * @member {string} [placementConstraints] The placement constraints as a
 * string. Placement constraints are boolean expressions on node properties and
 * allow for restricting a service to particular nodes based on the service
 * requirements. For example, to place a service on nodes where NodeType is
 * blue specify the following: "NodeColor == blue)".
 * @member {array} [correlationScheme] A list that describes the correlation of
 * the service with other services.
 * @member {array} [serviceLoadMetrics] The service load metrics is given as an
 * array of ServiceLoadMetricDescription objects.
 * @member {array} [servicePlacementPolicies] A list that describes the
 * correlation of the service with other services.
 * @member {string} [defaultMoveCost] Specifies the move cost for the service.
 * Possible values include: 'Zero', 'Low', 'Medium', 'High'
 * @member {string} serviceKind Polymorphic Discriminator
 */
export interface ServiceResourceUpdate extends ProxyResource {
  placementConstraints?: string;
  correlationScheme?: ServiceCorrelationDescription[];
  serviceLoadMetrics?: ServiceLoadMetricDescription[];
  servicePlacementPolicies?: ServicePlacementPolicyDescription[];
  defaultMoveCost?: string;
  serviceKind: string;
}

/**
 * @class
 * Initializes a new instance of the StatefulServiceProperties class.
 * @constructor
 * The properties of a stateful service resource.
 *
 * @member {boolean} [hasPersistedState] A flag indicating whether this is a
 * persistent service which stores states on the local disk. If it is then the
 * value of this property is true, if not it is false.
 * @member {number} [targetReplicaSetSize] The target replica set size as a
 * number.
 * @member {number} [minReplicaSetSize] The minimum replica set size as a
 * number.
 * @member {date} [replicaRestartWaitDuration] The duration between when a
 * replica goes down and when a new replica is created, represented in ISO 8601
 * format (hh:mm:ss.s).
 * @member {date} [quorumLossWaitDuration] The maximum duration for which a
 * partition is allowed to be in a state of quorum loss, represented in ISO
 * 8601 format (hh:mm:ss.s).
 * @member {date} [standByReplicaKeepDuration] The definition on how long
 * StandBy replicas should be maintained before being removed, represented in
 * ISO 8601 format (hh:mm:ss.s).
 */
export interface StatefulServiceProperties extends ServiceResourceProperties {
  hasPersistedState?: boolean;
  targetReplicaSetSize?: number;
  minReplicaSetSize?: number;
  replicaRestartWaitDuration?: Date;
  quorumLossWaitDuration?: Date;
  standByReplicaKeepDuration?: Date;
}

/**
 * @class
 * Initializes a new instance of the StatefulServiceUpdateProperties class.
 * @constructor
 * The properties of a stateful service resource for patch operations.
 *
 * @member {number} [targetReplicaSetSize] The target replica set size as a
 * number.
 * @member {number} [minReplicaSetSize] The minimum replica set size as a
 * number.
 * @member {date} [replicaRestartWaitDuration] The duration between when a
 * replica goes down and when a new replica is created, represented in ISO 8601
 * format (hh:mm:ss.s).
 * @member {date} [quorumLossWaitDuration] The maximum duration for which a
 * partition is allowed to be in a state of quorum loss, represented in ISO
 * 8601 format (hh:mm:ss.s).
 * @member {date} [standByReplicaKeepDuration] The definition on how long
 * StandBy replicas should be maintained before being removed, represented in
 * ISO 8601 format (hh:mm:ss.s).
 */
export interface StatefulServiceUpdateProperties extends ServiceResourceUpdateProperties {
  targetReplicaSetSize?: number;
  minReplicaSetSize?: number;
  replicaRestartWaitDuration?: Date;
  quorumLossWaitDuration?: Date;
  standByReplicaKeepDuration?: Date;
}

/**
 * @class
 * Initializes a new instance of the StatelessServiceProperties class.
 * @constructor
 * The properties of a stateless service resource.
 *
 * @member {number} [instanceCount] The instance count.
 */
export interface StatelessServiceProperties extends ServiceResourceProperties {
  instanceCount?: number;
}

/**
 * @class
 * Initializes a new instance of the StatelessServiceUpdateProperties class.
 * @constructor
 * The properties of a stateless service resource for patch operations.
 *
 * @member {number} [instanceCount] The instance count.
 */
export interface StatelessServiceUpdateProperties extends ServiceResourceUpdateProperties {
  instanceCount?: number;
}


/**
 * @class
 * Initializes a new instance of the OperationListResult class.
 * @constructor
 * Describes the result of the request to list Service Fabric operations.
 *
 * @member {string} [nextLink] URL to get the next set of operation list
 * results if there are any.
 */
export interface OperationListResult extends Array<OperationResult> {
  readonly nextLink?: string;
}
